<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebGL App</title>
<style>
  body { margin: 0; padding: 0; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body onload="init()">
<canvas id="myCanvas" width="640" height="480"></canvas>
<br>
Step: <input type="text" value="0.01" id="step" onchange="updateStep()">
<script>
var gl;
var verticesBuffer;
var shaderProgram;
var translationX = 0.0;
var translationY = 0.0;
var scaleX = 1.0;
var scaleY = 1.0;
var rotationZ = 0.0;
var step = 0.01;

function init() {
  var canvas = document.getElementById("myCanvas");
  gl = canvas.getContext("webgl");

  if (!gl) {
    console.error("WebGL no est√° disponible.");
    return;
  }

  var vertices = [
    // Columna izquierda
    -0.5, -0.5,
    -0.5, 0.5,
    -0.3, 0.5,
    -0.5, -0.5,
    -0.3, 0.5,
    -0.3, -0.5,
    // Columna derecha
    0.3, -0.5,
    0.5, -0.5,
    0.3, 0.5,
    0.3, 0.5,
    0.5, 0.5,
    0.5, -0.5,
    // Tejado
    -0.5, 0.5,
    0, 1,
    0.5, 0.5
  ];

  verticesBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

  var vertexShaderSource = `
    attribute vec2 a_position;
    uniform mat4 u_matrix;
    void main() {
      gl_Position = u_matrix * vec4(a_position, 0.0, 1.0, 1.0);
    }
  `;

  var fragmentShaderSource = `
    precision mediump float;
    void main() {
      gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0); // Amarillo
    }
  `;

  var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);
  gl.useProgram(shaderProgram);

  var positionAttributeLocation = gl.getAttribLocation(shaderProgram, "a_position");
  gl.enableVertexAttribArray(positionAttributeLocation);
  gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

  drawScene();
}

function createShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error("Error compiling shader:", gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

document.onkeydown = function (ev) {
  switch (ev.key) {
    case "ArrowLeft":
      translationX -= step;
      break;
    case "ArrowRight":
      translationX += step;
      break;
    case "ArrowUp":
      translationY += step;
      break;
    case "ArrowDown":
      translationY -= step;
      break;
    case "PageUp":
      scaleX += step;
      scaleY += step;
      break;
    case "PageDown":
      scaleX -= step;
      scaleY -= step;
      break;
    case "w":
      translationY += step;
      break;
    case "a":
      translationX -= step;
      break;
    case "s":
      translationY -= step;
      break;
    case "d":
      translationX += step;
      break;
    case "z":
      rotationZ += step * Math.PI / 180; // Convertir a radianes
      break;
    case "x":
      rotationZ -= step * Math.PI / 180; // Convertir a radianes
      break;
    case "c":
      rotationZ += step * Math.PI / 180; // Convertir a radianes
      break;
  }
  drawScene();
};

function drawScene() {
  gl.clearColor(0.0, 0.0, 1.0, 1.0); // Establecer el color de fondo azul
  gl.clear(gl.COLOR_BUFFER_BIT);
  
  var matrix = [
    scaleX * Math.cos(rotationZ), -scaleY * Math.sin(rotationZ), 0.0, 0.0,
    scaleX * Math.sin(rotationZ), scaleY * Math.cos(rotationZ), 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    translationX, translationY, 0.0, 1.0
  ];

  var matrixLocation = gl.getUniformLocation(shaderProgram, "u_matrix");
  gl.uniformMatrix4fv(matrixLocation, false, matrix);

  gl.drawArrays(gl.TRIANGLES, 0, 6); // Dibujar las columnas
  gl.drawArrays(gl.TRIANGLES, 6, 3); // Dibujar el tejado
}

function updateStep() {
  step = parseFloat(document.getElementById("step").value);
}
</script>
</body>
</html>
